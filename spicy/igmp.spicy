# Spicy grammar for the IGMP protocol.
# Supports IGMPv1, v2 and v3.
# See RFC 1112 (IGMPv1), RFC 2236 (IGMPv2) and RFC 3376 (IGMPv3)
# for information about the IGMP protocol.

module IGMP;

# ICMP message types
type Type = enum {
    MQ =   0x11,
    MRV1 = 0x12,
    MRV2 = 0x16,
    LG =   0x17,
    MRV3 = 0x22
};

# Version 3 Membership Report Group Record Types
type GroupType = enum {
    MODE_IS_INCLUDE =        1,
    MODE_IS_EXCLUDE =        2,
    CHANGE_TO_INCLUDE_MODE = 3,
    CHANGE_TO_EXCLUDE_MODE = 4,
    ALLOW_NEW_SOURCES =      5,
    BLOCK_OLD_SOURCES =      6
};

# Version 3 Membership Report Group Record
type Group = unit {
    group_type:     uint8 &convert=GroupType($$);
    aux_data_len:   uint8;
    num_sources:    uint16;
    multicast_addr: addr &ipv4;
    sources:        addr[self.num_sources] &ipv4;
    aux_data:       bytes &eod;
};

# Generic IGMP message
public type Message = unit {

    # Iterator, to parse message after checksum has been verified
    var start: iterator<stream>;
    on %init { self.start = self.input(); }

    ### FIRST STEP: verify message checksum

    var checksum_acc: uint32 = uint32(0);  # Checksum verification accumulator
    first_2_bytes:    uint16 { self.checksum_acc = self.first_2_bytes; }  # Add first 2 bytes to accumulator
    checksum:         uint16;  # Checksum value
    remaining_bytes:  uint16[] &eod;  # All remaining bytes until the end, grouped by 2 bytes
    # TODO: add error handling if message does not contain an even number of bytes
    
    # Add remaining bytes to accumulator
    on remaining_bytes foreach {
        self.checksum_acc += $$;
        if ( self.checksum_acc >= uint32(0x10000) ) {
            # If accumulator exceeds 0x10000, subtract 0xffff
            self.checksum_acc -= uint32(0xffff);
        }
    }

    # First pass finished, compare checksum values
    on remaining_bytes {
        self.checksum_acc = ~cast<uint16>(self.checksum_acc);
        if ( self.checksum_acc != self.checksum ) {
            # Checksum values differ, throw exception
            throw "Checksum verification failed ! Computed: %d, transmitted: %d" % (self.checksum_acc, self.checksum);
        }
        self.set_input(self.start);
    }

    ### SECOND STEP: Checksum verification passed, parse message

    msg_type:      uint8 &convert=Type($$);

    # Determine message type
    switch ( self.msg_type ) {
        Type::MQ   -> mq:   MembershipQuery;
        Type::MRV1 -> mrv1: MembershipReportV1;
        Type::MRV2 -> mrv2: MessageV2(True);
        Type::LG   -> lg:   MessageV2(False);
        Type::MRV3 -> mrv3: MembershipReportV3;
    };

    on %done { print self; }
};

# Generic IGMPv2 message
type MessageV2 = unit(is_membership_report: bool) {
    max_resp_time: uint8;
    checksum:      uint16;
    group_addr:    addr &ipv4;
};

# msg_type = 0x11: Membership Query
type MembershipQuery = unit {
    max_resp_code:   uint8;
    checksum:        uint16;
    group_addr:      addr &ipv4;
    flags: bitfield(8) {
        resv: 0..3;
        s:    4;
        qrv:  5..7;
    };
    qqic:            uint8;
    num_sources:     uint16;
    sources:         addr[self.num_sources] &ipv4;
    additional_data: bytes &eod;
};

# msg_type = 0x12: Version 1 Membership Report
type MembershipReportV1 = unit {
    :           uint8;  # Unused (1 byte)
    checksum:   uint16;
    group_addr: addr &ipv4;
};

# msg_type = 0x22: Version 3 Membership Report
type MembershipReportV3 = unit {
    :           void &size=1;  # Reserved (1 byte)
    checksum:   uint16;
    :           void &size=2;  # Reserved (2 bytes)
    num_groups: uint16;
    groups:     Group[self.num_groups];
};
