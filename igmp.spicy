module IGMP;

# ICMP message types
type Type = enum {
    MQ =   17,  # 0x11
    MRV1 = 18,  # 0x12
    MRV2 = 22,  # 0x16
    LG =   23,  # 0x17
    MRV3 = 34   # 0x22
};

# Version 3 Membership Report Group Record Types
type GroupType = enum {
    MODE_IS_INCLUDE =        1,
    MODE_IS_EXCLUDE =        2,
    CHANGE_TO_INCLUDE_MODE = 3,
    CHANGE_TO_EXCLUDE_MODE = 4,
    ALLOW_NEW_SOURCES =      5,
    BLOCK_OLD_SOURCES =      6
}

# Generic IGMP message
public type Message = unit {
    msg_type:      uint8 &convert=Type($$);

    # Determine message type
    switch ( self.msg_type ) {
        Type::MQ   -> mq:   MembershipQuery;
        Type::MRV1 -> mrv1: MembershipReportV1;
        Type::MRV2 -> mrv2: MessageV2;
        Type::LG   -> lg:   MessageV2;
        Type::MRV3 -> mrv3: MembershipReportV3;
    }

    on %done { print self; }
};

# Generic IGMPv2 message
type MessageV2 = {
    max_resp_time: uint8;
    checksum:      uint16;
    group_addr:    addr &ipv4;
}

# msg_type = 0x11: Membership Query
type MembershipQuery = unit {
    max_resp_code:   uint8;
    checksum:        uint16;
    group_addr:      addr &ipv4;
    flags: bitfield(8) {
        resv: 0..3;
        s:    4;
        qrv:  5..7;
    };
    qqic:            uint8;
    num_sources:     uint16;
    sources:         addr[] &ipv4 &size=4*num_sources;
    additional_data: bytes &eod;
};

# msg_type = 0x12: Version 1 Membership Report
type MembershipReportV1 = unit {
    unused:     uint8;
    checksum:   uint16;
    group_addr: addr &ipv4;
};

type Group = unit {
    group_type:     uint8 &convert=GroupType($$);
    aux_data_len:   uint8;
    num_sources:    uint16;
    multicast_addr: addr &ipv4;
    sources:        addr[] &ipv4 &size=4*num_sources;
    aux_data:       bytes &eod;
};

# msg_type = 0x22: Version 3 Membership Report
type MembershipReportV3 = unit {
    resv1:      uint8;
    checksum:   uint16;
    resv2:      uint16;
    num_groups: uint16;
    groups:     Group[num_groups];
};


#packet analyzer IoT::IGMP: